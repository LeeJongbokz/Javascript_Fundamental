
https://developer.mozilla.org/ko/docs/Learn/JavaScript/Objects/Object_prototypes

- Javascript에서는 객체를 상속하기 위하여 프로토타입이라는 방식을 사용함
-> 본 문서에서는 프로토타입 체인이 동작하는 방식을 설명하고,
   이미 존재하는 생성자에 메소드를 추가하기 위해
   프로토타입 속성을 사용하는 법을 알아봄
   
- 학습 목표    
1) Javascript 객체 프로토타입을 이해하고 프로토타입 체인이 어떻게 동작하는지,
   또 프로토타입 속성에 새 메소드를 추가하는 방법을 배움
   
   

- Javascript는 흔히 프로토타입 기반 언어라 불림
-> 모든 객체들이 메소드와 속성들을 상속 받기 위한 템플릿으로써
   프로토타입 객체(prototype object)를 가짐
-> 프로토타입 객체도 또 다시 상위 프로토타입 객체로부터 메소드와 속성을 
   상속 받을 수도 있고, 그 상위 프로토타입 객체도 마찬가지임
-> 이를 프로토타입 체인이라 부르며, 다른 객체에 정의된 메소드와 속성을 
   한 객체에서 사용할 수 있도록 하는 근간임
  
- 정확히 말하자면 상속되는 속성과 메소드들은 각 객체가 아니라 객체의 생성자의 prototype
  이라는 속성에 정의되어 있음

- Javascript에서는 객체 인스턴스와 프로토타입 간에 연결이 구성되며,
  (많은 브라우저들이 생성자의 prototype 속성에서 파생된 __proto__ 속성으로
   객체 인스턴스에 구현하고 있음)
  이 연결을 따라 프로토타입 체인을 타고 올라가며 속성과 메소드를 탐색함
  
  
- 자세히 알기 위해 예제를 하나 봄


### 프로토타입 객체 이해하기

- Person() 생성자를 작성했던 예제 코드로 되돌아가 봄
-> 브라우저로 예제 코드를 불러옴
-> 이 예제에서 생성자 함수를 정의함
-> 그리고 인스턴스도 하나 만듦
-> Javascript 콘솔에서 "person1."을 치게 되면 브라우저는 아래처럼
   해당 객체의 멤버 이름을 자동 완성 팝업으로 보여줌

- 위에서 person1의 프로토타입 객체인 Person()에 정의된 멤버들 
  - name, age, gender, interests, bio, greeting을 볼 수 있음
-> 또한 watch, valueOf처럼 Person()의 프로토타입 객체인 Object에 정의된
   다른 멤버들도 보실 수 있음
-> 이는 프로토타입 체인이 동작한다는 증거임

- 그럼 실제로는 Object에 정의되어 있는 메소드를 person1에서 호출하면 어떻게 될까?
  person1.valueOf()
  
- 이 메소드는 호출된 객체의 값을 단순 반환함
  이 때 일어나는 일은 아래와 같음
(1) 브라우저는 우선 person1 객체가 valueOf() 메소드를 가지고 있는지 체크함
(2) 없으므로 pereson1의 프로토타입 객체(Person() 생성자의 프로토타입)에 valueOf() 
    메소드가 있는지 체크함
(3) 여전히 없으므로 Person() 생성자의 프로토타입 객체의 프로토타입 객체(Object() 생성자의 프로토타입)
    가 valueOf() 메소드를 가지고 있는지 체크함
    여기에 있으니 호출하며 끝남

Note: 프로토타입 체인에서 한 객체의 메소드와 속성들이 다른 객체로 복사되는 것이 아님을    
      재차 언급함
      -> 위에서 보시다시피 체인을 타고 올라가며 접근할 뿐임


### 프로토타입 속성: 상속 받은 멤버들이 정의된 곳

- 그럼 상속 받은 속성과 메소드들은 어디에 정의되어 있을까요?
-> Object 레퍼런스 페이지에 가시면 좌측에 수많은 속성과 메소드들이 나열되어 있는 것을 볼 수 있음
-> 위 스크린샷에서 person1가 상속 받은 멤버들보다 훨씬 많음
   일부는 상속 되었지만 나머지는 아님
-> 왜일까?

- 정답은 상속 받는 멤버들은 prototype 속성에 정의되어 있기 때문임
-> Object로 시작하는게 아니라 Object.prototype.로 시작하는 것들임
-> prototype 속성도 하나의 객체이며, 프로토타입 체인을 통해 상속하고자 하는 속성과
   메소드를 담아두는 버킷으로 주로 사용되는 객체임
   
   
- 따라서 Object.prototype.watch(), Object.prototype.valueOf() 등은 
  생성자를 통해 새로 생성되는 인스턴스는 물론 Object.prototype을 상속 받는 객체라면
  어떤 객체에서든지 접근할 수 있음
  
- Object.is(), Object.keys() 등 prototype 버킷에 정의되지 않은 멤버들은 상속되지 않음
-> 이것들은 Object() 생성자에서만 사용할 수 있는 멤버들임

Note: 척 보기엔 이상함 - 함수에 불과한 생성자에 멤버를 정의한다니?
      함수 역시 객체의 하나임
      못 미더우시면 Function() 생성자 레퍼런스 페이지를 확인해 봄
      
      
  
  



  
  



