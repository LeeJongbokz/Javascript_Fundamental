https://developer.mozilla.org/ko/docs/Learn/JavaScript/Objects/Basics

- 이 글에서는 Javascript 객체와 관련된 기본적인 문법을 살펴보고,
  이전 코스에서 학습해서 이미 알고 있는 Javascript의 특징들과 
  우리가 이미 사용하고 있는 기능들이 이미 객체와 관련되어 있다는 사실을 
  다시 한 번 복습할 것임
  
- 목표
: 객체지향 프로그래밍에 대한 기본 이론을 이해하고,
  JavaScript에서 객체가 어떻게 처리되는지("대부분 객체임")
  학습 후, Javascript 객체를 실제로 이용하는 방법에 대해 알게되는 것을 목표로 함
  
  
- 객체 기본
: 객체는 관련된 데이터와 함수(일반적으로 여러 데이터와 함수로 이루어지는데,
  객체 안에 있을 때는 보통 프로퍼티와 메소드라고 부름)의 집합임
  예제를 통해서 실제 객체가 무엇인지 알아보도록 함 
  + 왜 객체는 관련된 데이터와 함수의 집합인가?
  - 객체는 데이터와 함수들로 구성됨
  
  여타 Javascript의 요소들과 마찬가지로, 객체를 생성하는 것은 변수를 정의하고
  초기화하는 것으로 시작함
  -> 아래의 JavaScript 코드를 oojs.html 파일의 script tag 사이에 입력하고
     저장한 후, 리로드 해봄 
       
     var person = {};
     [object Object]
     
  여러분은 벌써 첫 번째 객체를 생성함
  -> 하지만 텅 빈 객체여서 우린 이걸로 뭘 할 수는 없음
  -> 자, 이제 오브젝트를 다음과 같이 고쳐봄 
  
     var person = {
       name: ['Bob', 'Smith'],
       age: 32,
       gender: 'male',
       interests: ['music', 'skiing'],
       bio: function(){
         alert(this.name[0]+ ' ' + this.name[1] + ' is ' + this.age + ' years old')
       },
       greeting : function(){
         alert('Hi! I\'m ' + this.name[0] + '.');
       }
    };
    
   객체는 각기 다른 이름을 갖는 복수개의 멤버로 구성됨
   -> 한 쌍의 이름과 값은 ','로 구분되야 하고, 이름과 값은 ':'으로 분리됨 
   결국 문법은 아래와 같은 패턴이 됨 
   
   var objectName = {
      member1Name: member1Value,
      member2Name: member2Value,
      member3Name: member3Value,
   };
   
   객체를 구성하는 멤버의 값은 어떤 것이라도 될 수 있음
   -> 우리가 만든 person 객체는 문자열, 숫자, 배열 두 개와 두 개의 함수를 가지고 있음
   -> 처음 4개의 아이템은 데이터 아이템인데, 이걸 객체의 프로퍼티(속성)라고 부름
   -> 끝에 두 개의 아이템은 함수인데, 이 함수를 통해 데이터를 가지고 뭔가 일을 할 수 있게 됨
   -> 이걸 우리는 메소드라고 부름
   
   이런 객체는 객체 리터럴이라고 부름
   -> 객체를 생성할 때 컨텐츠를 그대로 대입함
   -> 객체 리터럴은 클래스로부터 생성하는 방식과는 다름
   -> 이 방식은 뒤에서 살펴보게 될 것임
   
   - 객체 리터럴을 사용해서 객체를 생성하는 것은 연속된 구조체나 연관된 데이터를
     일정한 방법으로 변환하고자 할 때 많이 쓰이는 방법임
   -> 예를 들면, 서버에게 주소를 데이터베이스에 넣어 달라고 요청하는 경우임
   -> 각 아이템들을 하나 하나 개별 전송하는 것보다, 하나의 객체를 전송하는 것이
      훨씬 효율적임
   -> 또 각 아이템들을 이름으로 구분해서 사용하기 원할 때도 배열을 사용하는 것보다
      훨씬 쉬움
      
    
   - 점 표기법
   
   1) 위에서, 우리는 객체의 프로퍼티와 메소드를 점 표기법을 통해 접근함
   -> 객체 이름은 네임스페이스처럼 동작함
   2) 객체내에 캡슐화되어있는 것에 접근하려면 먼저 점을 입력해야 함
   -> 그 다음 점을 찍고 접근하고자 하는 항목을 적음
   -> 간단한 프로퍼티의 이름일 수도 있음
   -> 배열의 일부이거나 객체의 메소드를 호출할 수도 있음
   
   person.age
   person.interests[1]
   person.bio()
   
   
   - 하위 namespaces
   
   - 다른 객체를 객체 멤버의 값으로 갖는 것도 가능함
   - 예를 들면, 다음과 같은 name 멤버를
   
   name: ['Bob', 'Smith']
   
   - 아래와 같이 바꿔볼 수 있음
   
   name: {
     first: 'Bob',
     last: 'Smith'
   },
   
   - 자, 이제 우리는 성공적으로 하위 namespace를 만듦
   -> 복잡해보이지만, 사실 그렇지도 않음
   -> 이 속성을 사용하려면 그저 끝에 다른 점을 하나 찍어주기만 하면 됨
   
   - person.name.first
   - person.name.last
   
   
   - 괄호 표기법
   
   -> 객체의 프로퍼티에 접근하는 다른 방법으로 괄호 표기법을 사용하는 것이 있음
    다음과 같이 사용하는 대신
    person.age
    person.name.first
    이렇게 사용할 수 있음
    person['age']
    person['name']['first']
    
    이런 방식은 배열 속에 있는 항목에 접근하는 방법과 매우 유사해 보이는데
    실제로도 이는 기본적으로 동일한 것임
    한 항목을 선택하기 위해 인덱스 숫자를 이용하는 대신에 각 멤버의 값들과
    연결된 이름을 이용함
    객체가 간혹 연관배열(associative arrays)이라고 불리는 것이 당연함
    연관배열은 배열이 숫자를 값에 연결하는 것과 같은 방법으로 스트링을 값에 매핑함
    
    - 객체 멤버 설정하기
    
    person.age = 45
    person['name']['last'] = 'Cratchit';
    
    person.age
    person['name']['last']
    
    person['eyes'] = 'hazel';
    person.farewell = function() { alert("Bye everybody!"); }
    
    person['eyes']
    person.farewell()
    
    - 대괄호 표현의 이점 중 하나는 멤버의 값을 동적으로 변경할 수 있을 뿐 아니라,
      멤버 이름까지도 동적으로 사용할 수 있다는 것임
    -> 만약 사용자가 두 개의 텍스트 입력을 통해서 people 데이터에 커스텀 값을 넣고
       싶어한다고 가정해보자
    -> 자, 만약 사용자가 두 개의 텍스트 입력을 통해서 people 데이터에 커스텀 값을
       넣고 싶어한다고 가정해보자
       
    
    - "this"는 무엇인가?
    
    자, 우리가 이제 보게될 메소드가 좀 이상하게 보일 수도 있음
    
    greeting: function() {
     alert('Hi! I'm ' + this.name.first + '.');
    }
    
    아마도 "this"가 뭔지 의아하실 것임
    -> this 키워드는 지금 동작하고 있는 코드를 가지고 있는 객체를 가리킴
    -> 위의 예제에서 this는 person 객체와 동일함
    -> 그럼 왜 직접 person 객체를 쓰지 않은 걸까요?
    -> 앞으로 보게 될 입문자를 위한 객체 지향 JavaScript 문서에서
       우리가 생성자를 공부하게 될 때, 혹은 그것 말고도 기타 등등의 상황에서
       this는 매우 유용하게 사용됨
       
       
    - 객체를 줄곧 사용해 옴
    
    예제코드를 따라하다보니, 이쯤 되면 슬슬 "점" 표기법을 사용하는 것이 꽤 자연스럽게 느껴질 것임
    물론 이 코스 내내 사용했기 때문임
    샘플에서 사용하였던 브라우저 내장 API나 Javascript 객체들은 실제로 우리가 공부했던 구조와
    완전히 동일한 방법으로 구현된 것들임
    
    자, 다음과 같이 String의 메소드를 사용했다고 가정함
    
    myString.split(',');
    
    String 클래스의 인스턴스가 가진 메소드를 사용하고 있음
    코드에서 String을 생성할 때마다 String의 인스턴스가 만들어지고,
    그렇게 만들어진 인스턴스는 당연히 공통적으로 사용할 수 있는 메소드와 프로퍼티를 가짐
    
    아래와 같이 도큐먼트 오브젝트 모델에 접근할때면,
    
    var myDiv  = document.createElement('div');
    var myVideo = document.querySelector('video');
    
    - Document 클래스의 인스턴스를 통해 메소드를 사용하고 있음
      각 웹페이지가 로딩될 때, Document 인스턴스가 만들어지고,
      전체 웹 페이지 구조와 컨텐츠 그리고 URL 같은 기능들을 제공하는 
      document가 호출됨
    -> 다시 말하지만 이건 여러 공통 메소드와 프로퍼티들이 
       이 인스턴스를 통해 사용가능하게 됨 
    
    - 모든 내장 객체/API가 자동으로 객체의 인스턴스를 생성하는 것은 아니라는 것에 주의함
    -> 예를 들어, Notifications API - 최근 브라우저들이 시스템 알림을 사용하게 하는 기능 -은
       사용자가 발생시키길 원하는 notification만을 선택하게 하는 생성자를 사용해야 함
       
    - 객체간 통신은 message passing 방식을 사용한다고 생각하는게 좋음
    -> 한 객체가 다른 객체에게 어떤 액션을 요청해야 하는 경우,
       그 객체는 다른 객체가 가지고 있는 메소드를 통해서 메시지를 보내는 것이고,
       응답을 기다리는 것임
       그 응답은 우리가 알고 있는 return 값임
       
       
    - 요약
    
    객체는 데이터와 연관된 함수를 저장하는데 매우 유용한 구조임
    만약 person 객체가 가지고 있는 모든 프로퍼티와 메소드를 따로 따로 분리된 
    변수와 함수로 구현하려고 한다면 그것이야 말로 비효율적이고 끔찍한 일이 될 것임
    변수명과 함수명들이 중복된다거나 하는 일도 비일비재 할 것임
    변수명과 함수명들이 중복된다거나 하는 일도 비일비재할 것임
    객체는 고유의 패키지에 우리의 정보를 안전하게 보호해주는 역할을 함
    
     
       
    
    
    
    
    
    
    
    
       
       
       
    
    
    
    
    
    
   
   
   
   
   
   
   
   
   
