
- 이벤트는 당신이 프로그래밍하는 시스템에서 발생하는 동작이나 사건을 의미함
-> 시스템은 당신이 특정한 방식으로 응답할 수 있도록 지정함(7/2)

- 예를 들어, 유저가 웹페이지에서 버튼을 클릭하면, 
  당신은 정보 박스를 보여줌으로써 응답하기를 원할 수 있음(7/2)
-> 이 아티클에서, 우리는 이벤트와 관련된 몇몇 중요한 컨셉을 논의하고,
   그것들이 어떻게 브라우저에서 동작하는지 살펴봄(7/2) 
   
 - 이것은 철저한 공부는 아님
 -> 단지 당신이 이 단계에서 알아야 할 것에 관한 것임(7/2)
 
 
 ### 일련의 운 좋은 이벤트
 
 - 위에서 언급했듯이, 이벤트는 당신이 프로그래밍하는 시스템에서 발생하는 
   동작이나 사건을 의미함(7/2)
 -> 시스템은 이벤트가 발생했을 때, 특정한 종류의 시그널을 발생시키고,
    이벤트가 발생했을 때, 특정 동작이 저절로 수행될 수 있도록 하는
    메커니즘을 제공함(7/2) 
 -> 예를 들어, 공항에서 항공기가 이륙하기에 활주로가 깔끔하면,
    시그널이 파일럿에게 전달되고, 그 결과로 항공기의 조종이 시작됨(7/2)
    
  - 웹의 케이스에서, 이벤트는 브라우저 윈도우 안에서 시작되며, 
    그 안에 있는 특정한 아이템에 결합되어 있음
  -> 이것은 단일한 element이거나 element의 집합이거나, 
     혹은 현재 tab에 로드된 HTML문서이거나, 전체 브라우저 윈도우일 수 있음(7/2)
  
  - 아주 많은 다양한 종류의 이벤트가 발생할 수 있음
     
  (1) 유저가 특정 element를 마우스로 클릭하거나, 혹은 특정 element위에 커서를 올려놓을 때(7/2)
  (2) 유저가 키보드에서 특정 키를 누를 때
  (3) 유저가 브라우저 윈도우를 리사이징하거나 닫을 때 (7/2)
  (4) 웹 페이지가 로딩을 끝낼 때
  (5) form이 제출될 때
  (6) 비디오가 플레이 되거나 멈추거나 혹은 플레이를 끝낼 때
  (7) 에러가 발생했을 때
  
  - 당신은 이것을 통해 아주 많은 이벤트에 응답할 수 있음을 알게 됨
  
  - 각각의 이용 가능한 이벤트는 이벤트 핸들러를 지니고 있음
  -> 이벤트 핸들러는 코드의 블락임(주로 당신이 프로그래머로서 만드는 자바스크립트 함수임)
  -> 이것은 이벤트가 발생했을 때, 동작함
  
  - 그런 코드의 블락이 이벤트가 발생했을 때 동작하도록 정의되면,
    우리는 이벤트 핸들러를 등록했다고 함
  -> 이벤트 핸들러는 종종 이벤트 리스너라고도 함  
  -> 그것들은 우리의 목적에 따라 꽤 교체가능함
  -> 그리고 그것들은 같이 동작함
  
  - 리스너는 이벤트의 발생을 듣고, 핸들러는 그것의 발생에 따라 동작하는 코드임(7/2)
  
  - 웹 이벤트는 core 자바스크립트 언어의 일부분은 아님
  -> 그것은 브라우저에 내장된 API의 일부분으로 정의됨(7/2) 
  
  ### 간단한 예시
  
  - 여기서 간단한 예시를 살펴봄
  -> 당신은 이미 이 코스에서 이벤트와 이벤트 핸들러가 사용되는 많은 예시를 봤음
  -> 단, 우리의 지식을 단단하게 하기 위해 복습을 함(7/2)
  
  - 아래의 예시에서 우리는 하나의 <button>을 갖고 있고, 그 버튼을 눌렀을 때, 
  -> background가 random한 색상으로 변하게 함
  
      <button> Change color</button>
      
      const btn = document.querySelector('button');
      
      function random(number){
         return Math.floor(Math.random()* (number+1));
      }
      
      btn.onclick = function(){
         const rndCol = 'rgb(' + random(255) + ',' + random(255) + ',' + random(255) + ')';
         document.body.style.backgroundColor = rndCol;
      }
      
   - 이 코드에서 우리는 btn이라고 부르는 버튼의 내부에서 reference를 저장함
   -> 이 때, Documnet.querySelector() 함수를 사용함
   
   - 우리는 또한 random number를 리턴하는 함수를 정의함
   
   - 코드의 세 번째 파트는 이벤트 핸들러임
   -> btn 상수는 <button> 엘리먼트를 가리키고, 이러한 타입의 object는 실행될 수 있는 많은 이벤트가 있음
   -> 그러므로 이벤트 핸들러는 가능함(7/2) 
   
   - 우리는 onclick 이벤트 핸들러를 익명 함수에 설정함으로써, click event의 실행을 들음
   -> 이 익명 함수는 random한 RGB 색을 발생시키고, <body>의 배경색을 세팅함(7/2) 
   
   - 이 코드는 클릭 이벤트가 <button> 엘리먼트에 발생했을 때 실행됨
   -> 즉, 유저가 클릭할 때마다 
   
   
   ### 이것은 단순히 웹 페이지가 아님
   
   - 여기서 언급할 중요한 점은 이벤트가 Javascript에만 유니크하지 않다는 점임
   -> 대부분의 프로그래밍 언어는 이벤트 모델과 같은 것이 있고,
      그 모델이 동작하는 방식은 Javascript의 방식과는 다름
   -> 사실 자바스크립트의 웹 페이지를 위한 이벤트 모델은, 자바스크립트의 이벤트 모델과 다른데,
      이는 다른 환경에서 사용됨에 기인함(7/2) 
      
   - 예를 들어, Node.js는 매우 인기 있는 자바스크립트 런타임임
   -> 개발자들은 자바스크립트를 활용해 네트워크와 서버 사이드 애플리케이션을 만들 수 있음
   
   - Node.js 이벤트 모델은 이벤트를 듣는 listener와 event를 주기적으로 발송하는 emitter에 의존함
   -> 이것은 꽤 달라보이지 않지만, 코드는 꽤 다름
   -> on()과 같은 함수로 이벤트를 등록하고, once()와 한 번 사용되면 해지되는 이벤트 리스너를 등록함
   
   - 다른 예시로서 당신은 또한 크로스 브라우저 애드온을 빌드할 수 있음
   -> 브라우저 기능 향상을 위해서
   -> WebExtenstions라는 기술을 사용함
   -> 이벤트 모델은 웹 이벤트 모델과 유사하지만 약간 다름
   -> 이벤트 리스너의 특성은 camel-cased이고, addListner 함수와 결합될 필요가 있음
   
   - 당신은 이 학습의 단계에서 그러한 환경을 이해할 필요는 없음
   -> 우리는 단지 당신이 이벤트가 다른 프로그래밍 환경에 따라 다를 수 있음을 명확하게 하고 싶음(7/2) 
