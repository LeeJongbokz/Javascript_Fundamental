https://developer.mozilla.org/ko/docs/Learn/JavaScript/First_steps/A_first_splash

- 지금 현재로서는 코드를 자세히 이해하려고 하지 않음
-> 단지 지금은 개념을 넓게 이해하고, 
   자바스크립트가 어떻게 운용되는지에 대한 아이디어가 필요함
+ 왜 지금은 개념을 넓게 이해하고, 자바스크립트가 어떻게 운용되는지에 대한 아이디어를 얻고자 하는가?
-> 큰 그림을 그리고자 하는 것이다. (6/7) 
+ 왜 큰 그림을 그리고자 하는가?
-> 큰 그림을 그려놓고 지식들을 연결해서 생각하기 위함이다. (6/7) 
   
- 프로그래밍에서 가장 어려운 것은 우리가 배우려는 문법이 아닌,
  실생활의 문제를 어떻게 프로그래밍에 적용시킬까 하는 부분임
-> 이는 일반적으로 프로그램이 필요한 부분과
   어떻게 코드가 문제를 해결하기 위해 작동되고,
   협업해야 되는지에 대한 설명을 알고 있어야 된다는 것임
+ 왜 프로그래밍에서 가장 어려운 것은 우리가 배우려는 문법이 아닌,
  실생활의 문제를 어떻게 프로그래밍에 적용시킬까 하는 부분인가?
-> 실생활의 문제를 어떻게 프로그래밍에 적용시킬까 하는 부분에서 
   프로그래밍적 사고를 가장 많이 그리고 깊게 해야 하기 때문이다. (6/7) 
 
 - 이는 프로그래밍 문법에 대한 경험과 노력, 그리고 창의성을 비롯한
   노력의 조합이 필요하다
 -> 코드를 많이 작성할수록 얻는 것은 더 많아진다
 -> 지금 당장 "프로그래머의 사고능력"으로 발전시킨다고는 보장하지 못하지만,
    이 수업을 통해 여러분들에게 프로그래머처럼 생각하는 많은 연습의 기회는 줄 수 있음
    
 + 프로그래머의 사고능력이란 무엇인가?
 -> 프로그램을 작성할 수 있는 능력, 프로그램을 작성하는 과정에서 발생하는 문제를 해결할 수 있는 능력,
    프로그램을 작성하는 과정에서 발생하는 문제를 해결하기 위해, 문제의 원인을 발견할 수 있는 능력,
    문제의 원인을 발견하기 위해 문제의 원인을 추론할 수 있는 능력,
    문제를 해결가능한 코드로 작성하는 능력, 문제를 해결가능한 코드로 작성하기 위한 문법적 지식에 대한 이해 능력
    등을 포함한다.(6/7) 
 
 + 왜 프로그래밍 문법에 대한 경험과 노력, 그리고 창의성을 비롯한 노력의 조합이 필요한가?
 -> 프로그래밍 문법에 대한 경험과 노력이 실생활의 문제를 프로그래밍으로 해결하는데 기반이 되기 때문이다. (6/7)
 -> 왜 프로그래밍 문법에 대한 경험이 중요한가?
 -> 프로그래밍 문법에 대한 경험을 통해서 실제 활용 능력을 향상시킬 수 있기 때문이다.(6/7) 
 + 왜 프로그래밍 문법에 대한 노력이 중요한가?
 -> 프로그래밍 문법에 대한 노력을 통해서 프로그래밍에 대한 문법을 익힐 수 있기 때문이다.(6/7) 
 + 왜 프로그래밍에 대한 창의성이 중요한가?
 -> 창의성은 문제에 대한 관점을 다르게 가져가는 것을 의미한다.(6/7)
 + 왜 문제에 대한 관점을 다르게 가져가는 것이 중요한가?
 -> 문제에 대한 관점을 다르게 가져가는 것이 문제를 해결하는 것으로 이어질 수 있기 때문이다. (6/7) 
 + 왜 문제에 대한 관점을 다르게 가져가는 것이 문제를 해결하는 것으로 이어질 수 있는가?
 -> 어떤 문제가 발생했을 때, 문제의 원인이 자신이 생각하지 못한 지점에 있을 수 있다. 
 -> 이 경우, 문제에 대한 관점을 다르게 가져가야만 그 문제를 '볼' 수 있게 된다.(6/7)
 -> 문제를 '볼'수 있게 된다는 것은 문제가 무엇인지 '알' 수 있게 된다는 것을 의미하고,
    문제가 무엇인지 '알'수 있게 된다는 것은 문제를 정의할 수 있게 된다는 것을 의미한다.
    그리고 문제를 정의할 수 있게 된다는 것은 문제를 해결할 수 있게 된다는 것을 의미한다. (6/7) 

+ 왜 코드를 많이 작성할수록 얻는 것은 더 많아지는가?
-> 코드를 많이 작성할수록 사고를 더 많이하게 되고, 이 과정에서 논리적인 사고 역량이 향상되기 때문이다.
-> 코드를 많이 작성할수록 사고를 더 많이 하게 되고, 관련된 지식을 습득할 수 있게 되기 때문이다.(6/7)  
-> 코드를 많이 작성할수록 문제에 대해서 더 깊게 고민하게 되고, 이 과정에서 문제를 정의하는 역량이 향상되기 때문이다.(6/7) 

 - 이러한 개념을 마음속에 품고, 앞으로 우리가 만들어나갈 예제를 살펴봄
 -> 여기서 실생활의 문제를 프로그래밍할 수 있도록 쪼개는 일반적인 과정을 봄

+ 실생활의 문제를 프로그래밍할 수 있도록 쪼갠다는 것이 무엇인가?
-> 실생활의 문제를 프로그래밍할 수 있도록 쪼갠다는 것은,
   문제를 사고하고 해결할 수 있는 단위로 만든다는 것을 의미한다. (6/7) 
+ 문제를 사고하고 해결할 수 있는 단위로 만든다는 것이 무엇인가?
-> 문제를 사고하고 해결할 수 있는 단위로 만든다는 것은
   문제의 난이도르 낮춘다는 것을 의미한다.
   뇌는 한 번에 사고할 수 있는 능력이 있다. 그 뇌가 사고할 수 있는 능력으로 문제를 해결할 수 있다.(6/7) 
+ 뇌가 한 번에 사고할 수 있는 능력이 있다는 것이 무엇인가?
-> 뇌가 한 번에 사고할 수 있는 능력의 단위가 정해져 있는 것을 의미한다.(6/7) 
+ 왜 뇌가 한 번에 사고할 수 있는 능력의 단위가 정해져 있는가?
-> 뇌가 한 번에 사고할 수 있는 능력의 단위가 정해져 있는 이유는 뇌의 기능과 관련된 것이다.(6/7) 
 
 - 만약 너의 상사가 예제에 관련되어 다음의 짧은 안내만 주어졌다고 생각하자
 
 -> 나는 간단하게 숫자 맞추기 게임을 만들고 싶다. 
    1과 100사이의 수 중에서 무작위로 선택되어야 하고,
    플레이어는 10번의 기회 안에 그 숫자를 맞춰야 한다.
    각 순서마다 숫자를 맞췄는지 틀렸는지는 당연히 알려줘야 하고,
    틀렸다면 큰지 작은지도 포함해서 말해야 한다.
    또한 이전에 써냈던 번호들도 보여줘야 한다.
    게임은 플레이어가 숫자를 맞추던가, 기회를 모두 소진하면 끝나게 된다.
    게임이 끝나면 플레이어가 다시 게임을 할 것인지 묻게 된다. 
 
 + 왜 간단하게 숫자 맞추기 게임을 하는가?
 -> 숫자 맞추기 게임을 구현하고자 하는 것이다.
 + 왜 1과 100사이의 수 중에서 무작위로 선택하는가?
 -> 1과 100사이의 수 중에서 무작위로 선택해서 숫자 맞추기를 구현하는 것이다.(6/7) 
 + 왜 플레이어는 10번의 기회 안에 그 숫자를 맞춰야 하는가?
 -> 10번의 기회 안에 숫자를 맞추는 것을 제약조건으로 제시한 것이다. (6/7) 
 + 왜 각 순서마다 숫자를 맞췄는지 틀렸는지는 당연히 알려줘야 하는가?
 -> 각 순서마다 숫자를 맞췄는지 틀렸는지 알려줌으로 인해서 사용자에게 행동을 유도하는 것이다.(6/7) 
 + 왜 틀렸다면 큰지 작은지도 포함해서 말해야 하는가?
 -> 큰지 작은지도 포함해서 말을 해야 사용자가 이어서 숫자를 입력할 수 있기 때문이다. 
 + 왜 이전에 써냈던 번호들도 보여줘야 하는가?
 -> 이전에 써냈던 번호들을 보여줘야 사용자에게 지침이 될 수 있기 때문이다. 
 + 왜 게임은 플레이어가 숫자를 맞추던가, 기회를 모두 소진하면 끝나게 되는가?
 -> 숫자를 맞추면 목적을 달성했으므로, 게임이 끝나게 되고,
    기회를 모두 소진하면 마찬가지로 기회가 더 이상 없으므로 게임이 끝나게 된다.(6/7)  
    
 
 - 위의 안내문을 보고 우선 문제를 가능한 한 작게 쪼개서,
   간단한 작업으로 만드는 것부터 시작함
 
 1. 1과 100 사이의 숫자 중 무작위로 추출함
 + 왜 1과 100사이의 숫자 중 무작위로 추출하는가?
 -> 1과 100사이의 숫자 중 무작위로 추출해서, 원하는 타겟의 숫자인지 보고자하는 것이다.(6/7) 
 + 왜 원하는 타겟의 숫자인지를 보고자 하는가?
 -> 원하는 타겟의 숫자를 맞추고자 하는 것이다.(6/7) 
 
 2. 1부터 플레이어의 차례를 기록함
 + 왜 1부터 플레이어의 차례를 기록하는가?
 -> 1부터 플레이어의 차례를 기록함으로 인해서,
    얼마만큼의 차례를 했는지를 나타내는 것이다.(6/7) 
 
 3. 플레이어에게 숫자를 맞출 수 있도록 함
 + 왜 플레이어에게 숫자를 맞출 수 있도록 하는가?
 -> 플레이어가 숫자를 맞추는 것이 이 프로그램의 목적이기 때문이다.
    플레이어가 숫자를 맞춤으로 인해서 해당 숫자가 맞는지 확인하는 것이다. 
 
 4. 숫자를 맞추면 어딘가에 저장하고, 사용자는 이전의 추측한 숫자를 볼 수 있도록 함
 + 왜 숫자를 맞추면 어딘가에 저장하고, 사용자는 이전의 추측한 숫자를 볼 수 있도록 하는가?
 -> 숫자를 맞추면 저장해야, 그 숫자를 사용자에게 보여줄 수 있기 때문이다.
 -> 사용자가 이전의 추측한 숫자를 봐야 그 숫자를 기준으로 다음 숫자를 추측할 수 있기 때문이다.(6/7) 
 
 5. 그 다음 숫자가 일치한지 확인함
 + 왜 그 다음 숫자가 일치하는지 확인하는가?
 -> 그 다음 숫자가 일치해야만 게임이 끝나기 때문이다.
    그 다음 숫자가 일치하는지 보려면 그 숫자가 목표하는 숫자와 일치하는지 확인해야 한다.(6/7) 
 
 6. 만약 일치한다면:
   1. 축하 메시지를 표시함
   2. 더 이상 숫자를 맞출 필요가 없음
   3. 플레이어가 다시 게임을 할지 물음
 + 왜 일치한다는 축하 메시지를 표시하는가?
 -> 일치한다면 프로그램이 마무리 된 것이기 때문이다 (6/7) 
 + 왜 더 이상 숫자를 맞출 필요가 없는가?
 -> 일치한다면 목표가 달성된 것이기 때문이다. (6/7)
 + 목표가 달성되었다는 것이 무엇인가?
 -> 숫자를 맞춘다는 목표를 달성했음을 의미한다.(6/7) 
 + 왜 플레이어가 다시 게임을 할지 묻는가?
 -> 플레이어가 다시 처음부터 게임을 한다는 선택지를 제공한 것이다.(6/7) 
   
 7. 숫자가 틀렸고, 차례가 남아 있다면:
   1. 틀렸다고 알림
   2. 다른 숫자를 입력할 수 있도록 함
   3. 차례가 1 증가함
 + 왜 숫자가 틀렸고, 차례가 남아 있다면, 틀렸다고 알리는가?
 -> 틀렸음을 알려야만 사용자가 틀렸음을 인지할 수 있기 때문이다.(6/7)
 + 왜 다른 숫자를 입력할 수 있도록 하는가?
 -> 다른 숫자를 입력해야 사용자가 숫자를 맞추는 쪽으로 나아갈 수 있기 때문이다.(6/7)
 + 왜 차례가 1 증가하는가?
 -> 차례가 1 증가해야만 전체 차례수를 확인할 수 있기 때문이다.(6/7) 
 + 왜 전체 차례수를 확인해야 하는가?
 -> 전체 차례수가 10회로 제한되는데, 그 제한되는 수 안에서 맞추도록 유도하기 위함이다.(6/7) 
 
 8. 숫자가 틀렸고, 차례가 없다면,
   1. 게임이 종료되었음을 알림
   2. 더 이상 숫자를 맞출 필요가 없음
   3. 플레이어가 다시 게임을 할지 물음
+ 왜 숫자가 틀렸고, 차례가 없다면 게임이 종료되었음을 알리는가?
-> 차례는 10번으로 제한되기 때문이다. 차례는 10번으로 제한되기 때문에, 그 이상의 차례로 가게 되면
   차례가 종료되었음을 알리는 것이다.(6/7) 
+ 왜 더 이상 숫자를 맞출 필요가 없는가?
-> 더 이상 숫자를 맞출 필요가 없는 이유는 이미 주어진 기회인 10회에 도달했기 때문이다.(6/7) 
   
 9. 게임이 재시작되면, 게임의 구조와 UI는 완전히 리셋되며,
    step1부터 다시 로직이 시작됨
 + 왜 게임이 재시작되면 게임의 구조와 UI는 완전히 리셋이 되는가?
 -> 게임의 구조와 UI가 완전히 리셋되어야만, 사용자가 처음부터 시작할 수 있기 때문이다.
 + 사용자가 처음부터 시작한다는 것이 무엇인가?
 -> 사용자가 처음부터 다시 게임을 시작하는 것을 의미한다.(6/7) 
 + 왜 사용자가 처음부터 다시 게임을 시작하는가?
 -> 주어진 10번의 기회를 다 소진했기 때문이다.(6/7) 
 + 왜 step1부터 다시 로직이 시작되는가?
 -> 사용자가 10번의 기회를 다 소진했기 때문에, 다시 0번부터 시작하는 것이다.(6/7) 
    
 + 왜 문제를 간단한 작업으로 만드는가?
 -> 문제를 간단한 작업으로 만듦으로 인해서 해결하기 쉬운 상태로 변환할 수 있기 때문이다.(6/7) 
 + 문제를 간단한 작업으로 만듦으로 인해서 해결하기 쉬운 상태로 변환한다는 것이 무엇인가?
 -> 논리적인 사고가 가능한 단위로 변환하는 것을 의미한다. 
 -> 보통 하나의 문제에는 여러 논리가 조합되어 있는데, 이 경우는 그 논리들을 분리해서 각각을 독립적인 논리로 분할하여야 한다.(6/7) 
 
 - 이제 다음 단계로 넘어가서 각 단계들을 코드로 어떻게 만들고,
   예제 소스와 통합하며, 그와 관련된 자바스크립트 기능은 무엇인지 살펴봄
 + 왜 그와 관련된 자바스크립트 기능은 무엇인지 살펴보는가?
 -> 그와 관련된 자바스크립트 기능이 무엇인지 알아야만 그 기능을 구현할 수 있기 때문이다.(6/7) 
 
 - 초기 구성
 1) 수업에 앞서 로컬에 number-guessing-game-start.html 파일을 저장하길 바람
 -> 그리고 파일을 에디터와 브라우저에서 동시에 열어봄
 -> 간단하게 요약된 설명과 추측하는 폼을 볼 때,
    아직 숫자를 입력하는 폼은 아무런 기능을 하지 않음
 + 왜 number-guessing-game-start.html 파일을 저장하는가?
 -> number-guessing-game-start.html 파일에 작성한 프로그램을 저장하고자 하는 것이다.(6/7) 
 
 
 - 여러분들의 코드를 추가하는 부분은 HTML안의 <script> 요소 사이에 있음
 + 왜 여러분들의 코드를 추가하는 부분은 HTML안의 <script> 요소 사이에 있는가?
 -> <script> 요소 사이에 Javascript 코드를 추가할 수 있기 때문이다.
 + 왜 <script> 요소 사이에 Javascript 코드를 추가할 수 있는가?
 -> <script> 요소 사이에 Javascript 코드를 추가하는 것이 규칙이기 때문이다.(6/7) 
 
 <script>
 
 // Your Javascript code here
 
 </script> 
 
 
 2) 데이터 저장을 위한 변수 추가
 -> 이제 시작해보자!
 -> 먼저 <script> 태그 안에 다음 코드들을 추가함
 
 var randomNumber = Math.floor(Math.random()*100) + 1;
 + 왜 Math.floor(Math.random()*100)+1을 추가하는가?
 -> Math.floor함수는 해당하는 숫자의 정수값을 내림해서 반환하는 것을 의미한다. 
 -> Math.random()은 0에서 1사이의 임의의 수를 반환하기 위해서 사용한다
 -> 그리고 여기에 100을 곱해준다는 것은 1에서 100사이의 임의의 수를 반환하는 것을 의미하고,
    여기에 floor함수를 덧붙이는 것은 그 수를 가장 가까운 정수로 내림해서 반환하는 것을 의미한다.(6/7) 
 
 var guesses = document.querySelector('.guesses);
 var lastResult = document.querySelector('.lastResult);
 var lowOrHi = document.querySelector('.lowOrHi');
 + 왜 document.querySelector를 사용하는가?
 -> document.querySelector는 지정한 id 혹은 class에 입력된 값을 변수에 저장하기 위해 사용하는 것이다.(6/7) 
 -> 여기서 .guesses 와 .lastResult는 각각 독립된 p태그 혹은 input 필드를 가리키는 id이다. 
 -> 따라서 다음과 같이 지정해줌으로 인해서 해당 input 필드의 값을 var 변수에 저장할 수 있게 된다.(6/7)  
 
 var guessSubmit = document.querySelector('.guessSubmit);
 var guessField = document.querySelector('.guessField);
 
 var guessCount = 1;
 var resetButton;
 + 왜 guessCount를 하는가?
 -> guessCount를 함으로 인해서 사용자가 몇 번 추정을 했는지를 확인해주기 위함이다.(6/7) 
 
 - 이 코드의 부분은 프로그램에서 사용할 데이터를 저장할 변수를 세팅해줌
 -> 변수들은 기본적으로 값을 저장하고 있음
 -> 변수들은 var이라는 키워드를 변수의 이름 앞에 붙여줌으로써 선언이 됨
 -> 변수에 넣고자 하는 값 앞에 등호(=)를 통해 변수에 값을 지정해줄 수 있음
 
 + 왜 이 코드의 부분은 프로그램에서 사용할 데이터를 저장하는가?
 -> 해당 변수를 저장하고, 해당 변수를 프로그램을 구성하는데 활용하기 위함이다.(6/7) 
 + 왜 변수들은 기본적으로 값을 저장하고 있는가?
 -> 변수들은 기본적으로 값을 저장해야만, 그 저장된 값을 활용해서 연산을 할 수 있기 때문이다.(6/7)  
 + 왜 변수들은 var이라는 키워드를 변수의 이름 앞에 붙여줌으로써 선언이 되는가?
 -> var은 variable의 줄임말로써, Javascript에서 변수를 선언하는데 사용하는 것이다.(6/7) 
 
 - 예제에서
 1) 첫 번째 변수 randomNumber는 수학적 알고리즘을 통해 계산해,
    1과 100사이의 임의의 수를 지정함
 2) 다음의 세 개의 변수들은 각각 HTML에서 결과 문장을 저장하는 기준으로 저장되고,
    코드 상에서 나중에 문장에 추가되도록 사용됨
    
 <p class="guesses"> </p>
 <p class="lastResult"> </p>
 <p class="lowOrHi"> </p>
 
 + 왜 다음의 세 개의 변수들은 각각 HTML에서 결과 문장을 저장하는 기준으로 사용하는가?
 -> 결과 문장을 HTML <p>태그의 영역에 저장하는 것이다.(6/7) 
 + 왜 결과 문장을 HTML <p> 태그의 영역에 저장하는가?
 -> 결과를 디스플레이해서 나타내는 것이다.(6/7) 
 
 3) 다음의 2개 변수는 다음의 입력과 버튼을 받고, 추측된 값을 나중에 받도록 하는 역할을 함
 
 <label for="guessField"> Enter a guess: </label><input type="text" id="guessField" class="guessField>
 <input type="submit" value="Submit guess" class="guessSubmit">
 
 + 왜 다음의 2개 변수는 다음의 입력과 버튼을 받고, 추측된 값을 나중에 받도록 하는 역할을 하는가?
 -> 입력을 받음으로 인해서, 해당 입력 값을 활용해서 프로그램을 구성하는 것이다. 
 
 
 4) 마지막 2개의 변수에는 추측 개수와 아직은 있지 않은 버튼을 리셋하는 변수가 있음
 
 
 
- 함수

다음으로 아래의 자바스크립트 코드를 추가함

function checkGuess(){
  alert('I am a placeholder");
}

-> 함수는 재사용이 가능한 코드의 묶음으로서 한 번만 명시하면 몇 번이고 실행이 가능하여,
   전체적인 코드에서 반복을 줄일 수 있음
+ 왜 함수는 재사용이 가능한 코드인가?
-> 재사용이 가능한 로직을 만들어 놓은 것이다. 재사용은 같은 로직을 계속해서 반복해서 작성하지 않고,
   하나의 로직을 반복적으로 활용할 수 있도록 할 수 있기 때문에 매우 유용하다(6/7) 
-> 이는 매우 유용함
+ 왜 함수는 매우 유용한가?
-> 하나의 로직을 반복적으로 사용할 수 있기 때문이다.(6/7) 
+ 왜 전체적인 코드에서 반복을 줄일 수 있는가?
-> 하나의 로직을 반복적으로 활용하므로 전체적인 코드에서 반복을 줄일 수 있다.(6/7) 

-> 함수를 정의하는 방법에는 여러 가지가 있지만, 일단 여기서는 가장 간단한 방법만 집중적으로 살펴봄
-> 앞에 function 키워드를 사용하고, 함수의 이름을 작성하며,
   함수의 이름 뒤에 괄호를 넣어줌으로써, 함수를 정의할 수 있음
-> 그러고 나서 중괄호로 묶어줌
-> 중괄호 안에는 함수가 호출되면 실행되는 반복적인 코드들이 들어 있음
+ 왜 함수 앞에 function 키워드를 사용하는가?
-> 함수 앞에 function 키워드를 사용하는 것은, 선언한 코드가 함수임을 명시하는 것이다.(6/7) 
+ 왜 중괄호로 묶어주는가?
-> 해당 함수에 관련된 로직의 영역을 정의하는 것이다.(6/7) 

- 코드는 괄호 앞에 위치한 함수의 이름을 적음으로 실행됨
-> 코드를 저장하고 브라우저에서 새로고침을 통해 실행해봄
+ 왜 코드는 괄호 앞에 위치한 함수의 이름을 적음으로 실행되는가?
-> 괄호 앞에 위치한 함수의 이름을 적음으로 인해서, 해당 함수를 호출할 수 있게 되기 때문이다.(6/7) 

- developer tools Javascript console에 들어가서 다음 문장을 입력해봄
-> checkGuess();

"I am a placeholder"라고 알리는 alert를 볼 수 있음
-> 여기서는 함수가 호출되면 alert가 생성되는 함수로 정의되어 있음
+ 왜 "I am a plceaholder"라는 alert를 볼 수 있는가?
-> 해당 함수 내에 해당 문장이 alert 되도록 지정해줬기 때문이다.(6/7) 

- 연산자

- 자바스크립트의 연산자는 테스트를 진행하고, 수학적인 것을 다루고,
  문자열을 결합하는 등의 것들을 가능케 함
+ 왜 자바스크립트의 연산자는 테스트를 진행하고, 수학적인 것을 다루고,
  문자열을 결합하는 등의 것들을 가능케 하는가?
-> 자바스크립트의 연산자는 프로그램 코드를 수학적인 결합이 가능하도록 지원함으로 인해서
   코드의 의미를 확장할 수 있도록 하는 것이다.(6/7) 
+ 코드의 의미를 확장한다는 것이 무엇인가?
-> 코드의 의미가 더해지거나, 하나의 코드가 추가적인 의미를 나타낼 수 있게 되는 것을 의미한다. (6/7) 
  
- 먼저 산술 연산자를 살펴봄
1) + : 더하기  6+9
2) - : 빼기  20-15
3) * : 곱하기 3*7
4) / : 나누기 10/5

- 또한 + 연산자는 문자열들을 서로 연결할 때에도 사용됨(이를 '문자열 접합'이라고 함)
-> 다음 코드를 입력해봄

var name = 'Bingo';
name;
var hello = ' says hello!';
hello;
var greeting = name + hello;
greeting

+ 왜 다음 코드를 입력해보는가?
-> 다음 코드를 입력함으로 인해서 자바스크립트의 연산자 기능이 동작함을 확인하고자 하는 것이다.
+ 왜 name과 hello를 더해주는가?
-> name과 hello를 더해줌으로 인해서 greeting이라는 변수를 새로 정의하는 것이다.(6/7) 



- '복합 대입 연산자'라고 불리는 소스를 간단하게 만드는 연산자도 있음
-> 예를 들어, 단순히 새로운 문자열을 기존에 있는 문자열에 추가하고,
   그 결과를 반환 받는 일을 하고 있다면 다음 코드를 사용할 수 있음
  
name += ' says hello!'

- 이 코드는 다음과 같은 의미임

name = name + ' says hello!';


- 참/거짓을 판명할 때, 비교연산자를 사용함

=== : Strict Equality
!== : Non-Equality
< : less than
> : greater than


- 조건문

함수가 반환되었을 때, 자리표시자 메시지를 표시하지 않는 것이 더 좋을 것이라고 봄
-> 우리는 사용자의 추측이 옳은것인지, 틀린것인지만 보고 적절하게 응답하도록만 함

이 시점에서 이제 현재 checkGuess()함수를 다음과 같이 수정함

function checkGuess(){
  var userGuess = Number(guessField.value);
  
  if(guessCount == 1){
     guess.textContent = 'Previous guesses: ';
  }
  
  guesses.textContent += userGuess + ' ';
  
  if(userGuess === randomNumber){
     lastResult.textContent = 'Congratulations! You got it right!';
     lastResult.style.backgroundColor = 'green';
     lowOrHi.textContent = '';
     setGameOver(); 
  }else if(guessCount === 10){
     lastResult.textContent = '!!!GAME OVER!!!'
     setGameOver();
  }else{
     lastResult.textContent = 'Wrong!';
     lastResult.style.backgroundColor = 'red';
     if(userGuess < randomNumber){
      lowOrHi.textContent = 'Last guess was too low!'
     }else if(userGuess > randomNumber){
      lowOrHi.textContent = 'Last guess was too high!;
     }
  }만
  
  guessCount++;
  guessField.value = '';
  guessField.focus();
}


- 2번 줄까지는 userGuess변수를 선언하고, 텍스트 필드에서 입력된 현재 값들을
  변수의 값으로 지정함
-> 여기서는 빌트인된 Number() 메소드로 실행됨 

- 그러고나서 처음으로 조건문을 맞닥뜨림
-> 조건문 블록은 조건이 옳은지 그른지에 따라 선택적으로 실행됨
-> 함수와 비슷하나 꼭 그렇지는 않음
-> 가장 간단한 조건문의 형태는 if를 사용하고, 괄호가 있고, 중괄호가 있음
-> 괄호 안에는 조건이 삽입됨
-> 만약 조건문이 옳다면, 중괄호안의 코드들이 실행됨
-> 함수와 비슷하나 꼭 그렇지는 않음

- 조건문이 옳다면, 중괄호안의 코드들이 실행됨
-> 거짓이라면 다음 코드로 넘어가게 됨
-> 이 코드에서 조건문은 guessCount 변수가 1인지임
   (즉, 현재 플레이어의 게임이 처음인지 아닌지를 판단하는 조건)

guessCount === 1

- 참이라면 guesses 변수의 텍스트는 "Previous Guesses: "가 됨
-> 그렇지 않다면 실행되지 않음

- 6번 줄에서는 현재의 userGuess 값에 마지막 guesses 문장을 추가하고,
  끝에 공백을 더함으로서 각각의 추측한 수끼리 간격을 두고 보여짐
     
     
- 참이라면 guesses 변수의 텍스트는 Previous guesses가 됨
-> 그렇지 않다면 실행되지 않음

- 6번 줄에서는 현재의 userGuess값에 마지막 guesses 문장을 추가하고, 끝에 공백을 더함으로써,
  각각의 추측한 수끼리 간격을 두고 보여짐

- 다음 블록도 한 번 살펴봄
-> 첫 if(){}는 처음에 지정한 randomNumber와 사용자가 추측한 값(userGuess)이 같은지 봄
-> 참이라고 계산되면 플레이어는 숫자를 맞춘 것이고, 게임을 이기게 됨
-> 따라서 플레이어에게 초록색, 인포메이션 박스로 축하 메시지를 보여주고,
   게임을 더할지와 관련한 setGameOver() 함수를 불러옴
   
- 이제 else if(){} 구조를 사용하여 다른 조건문을 추가하게 됨
-> 이 조건은 사용자가 마지막 순서인지를 계산함
-> 참이라면 프로그램은 이전과 같은 블록을 실행함
-> 대신 게임을 이기지는 않았기 때문에 축하 메시지는 제외됨

- 마지막 블록은 앞선 두 개의 조건이 모두 거짓일 때 실행됨(ex) 숫자를 맞추지도 못하고 차례가 남았을 때)
-> 이 경우 틀렸음을 알려주고, 정답보다 숫자가 큰지 작은지도 계산하여 적절한 메시지를 표시하도록 함

- 함수상의 마지막 3줄은 다음 숫자 추측을 위한 것임
-> guessCount변수에 1을 더함으로써 사용자의 차례가 지나갔음을 알음
   (++이란 증감 연산자임)
-> 그리고 값에 상관없이 텍스트필드를 공란으로 만들고,
   커서를 위치시키므로, 다음 값이 입력될 수 있도록 함
   

### 이벤트

- 여기서 우리는 checkGuess() 함수를 잘 구현해보았지만, 
  아직 호출하지 않았기 때문에 아무런 역할도 하지 않음
-> 실제로는 "Submit Guess" 버튼이 눌러져야 호출받도록 할 것이며,
   이벤트를 사용해서 구현할 것임

- 이벤트란 버튼을 클릭하고, 페이지가 로딩되고, 비디오가 실행되는 등의
  코드가 실행되기 위한 응답으로 브라우저상에서 일어나는 액션임
-> 이벤트가 발생하여 이벤트를 처리하는 것을 이벤트 리스너,
   이벤트가 발생했을 때 실행되는 코드 블록을 이벤트 핸들러라고 함
   
- checkGuess()함수의 중괄호가 끝난 뒤, 다음의 코드를 추가해 봄

  guessSubmit.addEventListener('click', checkGuess);
  
  - 이는 guessSubmit 버튼에 이벤트 리스너를 추가하는 과정임
  -> 두 개의 입력을 가지는 addEventListener 메소드임
  -> 문자열로서 클릭을 처리하는 이벤트이고, 이벤트가 발생했을 때
     실행하고자 하는 코드는 checkGuess 함수임
  -> 특히, addEventListener() 안에서는 함수의 괄호가 필요 없다는 것에 주의함
  
  - 코드를 저장하고 새로고침을 해봄
  -> 예제가 실행됨
  -> 아직 게임이 종료되면 실행되는 setGameOver() 함수가 정의되지 않았으므로,
     정답을 맞췄을 때나 추측에 상관없이 실행되었다면 프로그램의 실행이 멈춰야 함
  -> 필요한 코드를 작성하고 함수를 추가해봄
  
 
  ### 함수로 프로그램 종료하기
  
  - setGameOver() 함수를 코드 아래쪽에 추가하고 살펴봄
  -> 자바스크립트 코드의 맨 아래쪽에 추가함
  
  function setGameOver(){
     guessField.disabled = true
     guessSubmit.disabled = true
     resetButton = document.createElement('button');
     resetButton.textContent = 'Start new game';
     document.body.appendChild(resetButton);
     resetButton.addEventListener('click', resetGame);
   }
   
  - 2-3번줄은 텍스트 입력과 disabled 속성을 true로 함으로써 작동되지 않도록 함
  -> 그렇지 않다면 사용자들이 게임이 종료된 후에도 계속 정답을 제출할 것이기 때문에 필수적임
  
  - 4-6번줄은 새로운 <button> 엘리먼트를 생성하고, "Start new game"라고 표시되게
    지정하고, 현재 HTML 아래쪽에 추가함
   
  - 7번줄은 새 버튼으로 하여금 이벤트 리스너를 지정하여 클릭되면 resetGame() 함수가 실행되도록 함
  
  
  - 물론 이 함수도 정의해야 함. 또다시 코드의 가장 아래에 다음 코드를 추가함
  
 
 function resetGame(){
 
    guessCount = 1;
    
    var resetParas = document.querySelectorAll('.resultParas p');
    
    for(var i = 0; i< resetParas.length; i++){
       resetParas[i].textContent = '';
    }
    
    resetButton.parentNode.removeChild(resetButton);
    
    guessField.disabled = false;
    guessSubmit.disabled = false;
    guessField.value = '';
    guessField.focus();
    
    lastResult.style.backgroundColor = 'white';
    
    randomNumber = Math.floor(Math.random()*100) + 1;
    
}


- 앞서 보는 함수 블록 코드는 게임이 어떻게 시작되고 사용자가 다시 시작할 수 있도록 
  초기화하는 코드임

guessCount 변수를 1로함
표시된 정보를 모두 초기화함
코드상에서 초기화 버튼을 모두 제거함
폼 작성을 위해 텍스트를 입력하는 곳을 비워놓고 커서를 위치시킴
lastResult 변수 상의 문장 배경색을 제거함
임의의 수를 다시 지정함으로써 앞선 randomNumber와 겹치지 않도록 다시 설정함


## 반복문

- 반복문은 프로그래머가 지정한 코드의 부분을 조건에 부합할때까지 계속 실행시키는
  프로그래밍에서 중요한 개념 중 하나임
  
for(var i=1; i<21; i++){
   console.log(i);
}

- 어떤 일이 일어났는가?
-> 숫자 1부터 20까지 차례대로 콘솔창에 표시됨을 알 수 있다(6/9)
-> 이는 반복이라는 컨셉 때문임
-> for 반복문에는 세 개의 입력값이 있음

1. 시작값
- 위 코드에서는 1부터 시작하였지만, 프로그래머 임의대로 지정할 수 있음
-> i대신 다른 변수를 사용할 수 있지만, 짧고 기억하기 쉬운 관습으로 인해
   간단한 알파벳 i가 주로 사용됨

2. 종료 조건
- 여기서는 i < 21이라고 명시됨
-> 이는 i가 21보다 작을때까지 반복이 이루어진다는 말임
-> i가 21이 되었을 때, 반복은 종료됨

3. 증감식
- i++이라고 명시된 것은 i에 1씩 더하라는 의미임
-> 반복은 i의 값에 따라 i가 21이 될때까지 반복함
-> 여기서는 console.log()를 통해 콘솔창에 i값을 반복적으로 출력시킴

- 앞선 resetGame() 함수에서의 반복문을 살펴봄

var resetParas = document.querySelectorAll('.resultPara p');
for(var i=0; i<resetParas.length; i++){
   resetParas[i].textContent = '';
}

-> 이 코드에서는 querySelectorAll() 메소드를 사용하여 <div class="resultParas">안의
   모든 문장들의 배열을 변수로 만듦
-> 그리고 반복을 통해 각각의 배열 원소에 접근하여 내용을 제거함 


## 객체에 대한 간단한 고찰

- 이제 마지막으로 한 단계 더 나아갈 수 있는 부분을 배워봄
-> var resetButton; 아래에 다음 코드를 추가해봄

guessField.focus();

- 여기서는 focus()메소드를 통해 자동으로 커서를 뜨자마자 
  <input>텍스트 필드에 위치시킬 수 있기 때문에
  사용자가 처음에 폼 필드를 클릭할 필요 없이
  바로 글을 쓸 수 있게 됨
-> 아무것도 아닌 것처럼 보이지만, 사용자에게 굉장히 편리함을 주기 때문에
   프로그램에서 좋은 효과를 가져다줌 
   
- 자바스크립트에서는 모든 것이 객체임
-> 객체는 하나의 그룹안에 관계되는 기능(함수)들을 모아 놓은 것임
-> 지금은 간단히 브라우저에 내장된 객체를 사용함으로써 
   좀 더 많은 일을 해보는 것에 중점을 둠
   
- 여기서는 먼저 HTML의 입력 폼 필드의 정보를 저장하는 guessField 변수를 생성해봄

var guessField = document.querySelector('.guessField');

- 이 정보를 얻기 위해 document 객체의 querySelector 메소드를 사용함
-> querySelector()는 특정 정보(필요한 요소를 추출하는 CSS Selector)를
   가져오는 역할을 함 

- 이제 <input> 요소의 정보를 담고 있기 때문에 속성과 메소드를 접근할 수 있게 됨
-> 입력 요소에 이용 가능한 메소드 중 하나가 focus()이며,
   따라서 이 메소드를 통해 텍스트 입력에 커서를 가져다 놓을 수 있음
   
- 폼 요소의 정보를 가지고 있지 않은 변수는 focus()를 사용할 수 없음
-> 예를 들어, guesses 변수는 <p> 요소의 정보를 가지고 있고,
   guessCount 변수는 단순한 숫자를 포함하고 있음
   
 
## 브라우저 객체로 다루기

- 이제 브라우저를 객체로서 다뤄봄
1. 먼저 브라우저에서 프로그램을 열음
2. 다음 browser developer tools를 실행하고, 자바스크립트 콘솔창을 활성화함
3. guessField의 입력과 콘솔에서 <input> 요소를 포함한 변수를 보여줌
-> 변수를 포함한 실행환경 상에 존재하는 객체이름을 콘솔이 자동완성하는 것도 알아야 함
4. 다음 코드를 입력함
   guessField.value = 'Hello';
   value 속성은 텍스트 필드를 통해 입력되는 현재 값을 나타냄
5. guesses에 입력하고 반환값을 살펴봄
  -> 콘솔창에서 변수가 <p>요소가 있음을 보여줌
6. 다음 코드를 입력함
   guesses.value
-> 브라우저에서 아무런 문장이 없기 때문에 undefined라고 리턴됨

7. 대신 다음 코드에서 문자를 변경/추가하기 위해서는 textContent 속성을 사용함
   guesses.textContent = 'Where is my paragraph?';
 
8. 그러면 이제 다양한 작업을 할 수 있으니, 하나하나 시도해 봄
   guesses.style.backgroundColor = 'yellow';
   guesses.style.fontSize = '200%';
   guesses.style.padding = '10px';
   guesses.style.boxShadow = '3px 3px 6px black';
   
- 페이지의 모든 요소들은 style 속성을 가지고 있기 때문에
-> 모든 요소에 적용 가능한 CSS 스타일을 포함한 속성을 가진 객체를 포함하고 있음
-> 이는 자바스크립트 상에서 CSS 스타일을 동적으로 지정할 수 있음을 말함 


   




  
  
  
  


   
 
 
 
 
 
 
